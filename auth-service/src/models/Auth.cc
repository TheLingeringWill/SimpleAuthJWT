/**
 *
 *  Auth.cc
 *  DO NOT EDIT. This file is generated by drogon_ctl
 *
 */
// NOLINTBEGIN
#include "Auth.h"

#include <drogon/utils/Utilities.h>
#include <string>

using namespace drogon;
using namespace drogon::orm;
using namespace drogon_model::famy_auth;

const std::string Auth::Cols::_id = "id";
const std::string Auth::Cols::_verify_token = "verify_token";
const std::string Auth::Cols::_refresh_token = "refresh_token";
const std::string Auth::Cols::_otp = "otp";
const std::string Auth::primaryKeyName = "id";
const bool Auth::hasPrimaryKey = true;
const std::string Auth::tableName = "auth";

const std::vector<typename Auth::MetaData> Auth::metaData_ = {
  {           "id",     "int64_t", "bigint", 8, 0, 1, 1},
  { "verify_token", "std::string",   "text", 0, 0, 0, 0},
  {"refresh_token", "std::string",   "text", 0, 0, 0, 0},
  {          "otp", "std::string",   "text", 0, 0, 0, 0}
};

const std::string&
Auth::getColumnName(size_t index) noexcept(false)
{
  assert(index < metaData_.size());
  return metaData_ [index].colName_;
}

Auth::Auth(const Row& r, const ssize_t indexOffset) noexcept
{
  if(indexOffset < 0)
  {
    if(! r ["id"].isNull())
    {
      id_ = std::make_shared<int64_t>(r ["id"].as<int64_t>());
    }
    if(! r ["verify_token"].isNull())
    {
      verifyToken_ =
        std::make_shared<std::string>(r ["verify_token"].as<std::string>());
    }
    if(! r ["refresh_token"].isNull())
    {
      refreshToken_ =
        std::make_shared<std::string>(r ["refresh_token"].as<std::string>());
    }
    if(! r ["otp"].isNull())
    {
      otp_ = std::make_shared<std::string>(r ["otp"].as<std::string>());
    }
  }
  else
  {
    size_t offset = (size_t)indexOffset;
    if(offset + 4 > r.size())
    {
      LOG_FATAL << "Invalid SQL result for this model";
      return;
    }
    size_t index;
    index = offset + 0;
    if(! r [index].isNull())
    {
      id_ = std::make_shared<int64_t>(r [index].as<int64_t>());
    }
    index = offset + 1;
    if(! r [index].isNull())
    {
      verifyToken_ = std::make_shared<std::string>(r [index].as<std::string>());
    }
    index = offset + 2;
    if(! r [index].isNull())
    {
      refreshToken_ =
        std::make_shared<std::string>(r [index].as<std::string>());
    }
    index = offset + 3;
    if(! r [index].isNull())
    {
      otp_ = std::make_shared<std::string>(r [index].as<std::string>());
    }
  }
}

Auth::Auth(
  const Json::Value& pJson,
  const std::vector<std::string>& pMasqueradingVector
) noexcept(false)
{
  if(pMasqueradingVector.size() != 4)
  {
    LOG_ERROR << "Bad masquerading vector";
    return;
  }
  if(! pMasqueradingVector [0].empty() && pJson.isMember(pMasqueradingVector [0]))
  {
    dirtyFlag_ [0] = true;
    if(! pJson [pMasqueradingVector [0]].isNull())
    {
      id_ = std::make_shared<int64_t>(
        (int64_t)pJson [pMasqueradingVector [0]].asInt64()
      );
    }
  }
  if(! pMasqueradingVector [1].empty() && pJson.isMember(pMasqueradingVector [1]))
  {
    dirtyFlag_ [1] = true;
    if(! pJson [pMasqueradingVector [1]].isNull())
    {
      verifyToken_ =
        std::make_shared<std::string>(pJson [pMasqueradingVector [1]].asString()
        );
    }
  }
  if(! pMasqueradingVector [2].empty() && pJson.isMember(pMasqueradingVector [2]))
  {
    dirtyFlag_ [2] = true;
    if(! pJson [pMasqueradingVector [2]].isNull())
    {
      refreshToken_ =
        std::make_shared<std::string>(pJson [pMasqueradingVector [2]].asString()
        );
    }
  }
  if(! pMasqueradingVector [3].empty() && pJson.isMember(pMasqueradingVector [3]))
  {
    dirtyFlag_ [3] = true;
    if(! pJson [pMasqueradingVector [3]].isNull())
    {
      otp_ =
        std::make_shared<std::string>(pJson [pMasqueradingVector [3]].asString()
        );
    }
  }
}

Auth::Auth(const Json::Value& pJson) noexcept(false)
{
  if(pJson.isMember("id"))
  {
    dirtyFlag_ [0] = true;
    if(! pJson ["id"].isNull())
    {
      id_ = std::make_shared<int64_t>((int64_t)pJson ["id"].asInt64());
    }
  }
  if(pJson.isMember("verify_token"))
  {
    dirtyFlag_ [1] = true;
    if(! pJson ["verify_token"].isNull())
    {
      verifyToken_ =
        std::make_shared<std::string>(pJson ["verify_token"].asString());
    }
  }
  if(pJson.isMember("refresh_token"))
  {
    dirtyFlag_ [2] = true;
    if(! pJson ["refresh_token"].isNull())
    {
      refreshToken_ =
        std::make_shared<std::string>(pJson ["refresh_token"].asString());
    }
  }
  if(pJson.isMember("otp"))
  {
    dirtyFlag_ [3] = true;
    if(! pJson ["otp"].isNull())
    {
      otp_ = std::make_shared<std::string>(pJson ["otp"].asString());
    }
  }
}

void
Auth::updateByMasqueradedJson(
  const Json::Value& pJson,
  const std::vector<std::string>& pMasqueradingVector
) noexcept(false)
{
  if(pMasqueradingVector.size() != 4)
  {
    LOG_ERROR << "Bad masquerading vector";
    return;
  }
  if(! pMasqueradingVector [0].empty() && pJson.isMember(pMasqueradingVector [0]))
  {
    if(! pJson [pMasqueradingVector [0]].isNull())
    {
      id_ = std::make_shared<int64_t>(
        (int64_t)pJson [pMasqueradingVector [0]].asInt64()
      );
    }
  }
  if(! pMasqueradingVector [1].empty() && pJson.isMember(pMasqueradingVector [1]))
  {
    dirtyFlag_ [1] = true;
    if(! pJson [pMasqueradingVector [1]].isNull())
    {
      verifyToken_ =
        std::make_shared<std::string>(pJson [pMasqueradingVector [1]].asString()
        );
    }
  }
  if(! pMasqueradingVector [2].empty() && pJson.isMember(pMasqueradingVector [2]))
  {
    dirtyFlag_ [2] = true;
    if(! pJson [pMasqueradingVector [2]].isNull())
    {
      refreshToken_ =
        std::make_shared<std::string>(pJson [pMasqueradingVector [2]].asString()
        );
    }
  }
  if(! pMasqueradingVector [3].empty() && pJson.isMember(pMasqueradingVector [3]))
  {
    dirtyFlag_ [3] = true;
    if(! pJson [pMasqueradingVector [3]].isNull())
    {
      otp_ =
        std::make_shared<std::string>(pJson [pMasqueradingVector [3]].asString()
        );
    }
  }
}

void
Auth::updateByJson(const Json::Value& pJson) noexcept(false)
{
  if(pJson.isMember("id"))
  {
    if(! pJson ["id"].isNull())
    {
      id_ = std::make_shared<int64_t>((int64_t)pJson ["id"].asInt64());
    }
  }
  if(pJson.isMember("verify_token"))
  {
    dirtyFlag_ [1] = true;
    if(! pJson ["verify_token"].isNull())
    {
      verifyToken_ =
        std::make_shared<std::string>(pJson ["verify_token"].asString());
    }
  }
  if(pJson.isMember("refresh_token"))
  {
    dirtyFlag_ [2] = true;
    if(! pJson ["refresh_token"].isNull())
    {
      refreshToken_ =
        std::make_shared<std::string>(pJson ["refresh_token"].asString());
    }
  }
  if(pJson.isMember("otp"))
  {
    dirtyFlag_ [3] = true;
    if(! pJson ["otp"].isNull())
    {
      otp_ = std::make_shared<std::string>(pJson ["otp"].asString());
    }
  }
}

const int64_t&
Auth::getValueOfId() const noexcept
{
  const static int64_t defaultValue = int64_t();
  if(id_)
  {
    return *id_;
  }
  return defaultValue;
}

const std::shared_ptr<int64_t>&
Auth::getId() const noexcept
{
  return id_;
}

void
Auth::setId(const int64_t& pId) noexcept
{
  id_ = std::make_shared<int64_t>(pId);
  dirtyFlag_ [0] = true;
}

const typename Auth::PrimaryKeyType&
Auth::getPrimaryKey() const
{
  assert(id_);
  return *id_;
}

const std::string&
Auth::getValueOfVerifyToken() const noexcept
{
  const static std::string defaultValue = std::string();
  if(verifyToken_)
  {
    return *verifyToken_;
  }
  return defaultValue;
}

const std::shared_ptr<std::string>&
Auth::getVerifyToken() const noexcept
{
  return verifyToken_;
}

void
Auth::setVerifyToken(const std::string& pVerifyToken) noexcept
{
  verifyToken_ = std::make_shared<std::string>(pVerifyToken);
  dirtyFlag_ [1] = true;
}

void
Auth::setVerifyToken(std::string&& pVerifyToken) noexcept
{
  verifyToken_ = std::make_shared<std::string>(std::move(pVerifyToken));
  dirtyFlag_ [1] = true;
}

void
Auth::setVerifyTokenToNull() noexcept
{
  verifyToken_.reset();
  dirtyFlag_ [1] = true;
}

const std::string&
Auth::getValueOfRefreshToken() const noexcept
{
  const static std::string defaultValue = std::string();
  if(refreshToken_)
  {
    return *refreshToken_;
  }
  return defaultValue;
}

const std::shared_ptr<std::string>&
Auth::getRefreshToken() const noexcept
{
  return refreshToken_;
}

void
Auth::setRefreshToken(const std::string& pRefreshToken) noexcept
{
  refreshToken_ = std::make_shared<std::string>(pRefreshToken);
  dirtyFlag_ [2] = true;
}

void
Auth::setRefreshToken(std::string&& pRefreshToken) noexcept
{
  refreshToken_ = std::make_shared<std::string>(std::move(pRefreshToken));
  dirtyFlag_ [2] = true;
}

void
Auth::setRefreshTokenToNull() noexcept
{
  refreshToken_.reset();
  dirtyFlag_ [2] = true;
}

const std::string&
Auth::getValueOfOtp() const noexcept
{
  const static std::string defaultValue = std::string();
  if(otp_)
  {
    return *otp_;
  }
  return defaultValue;
}

const std::shared_ptr<std::string>&
Auth::getOtp() const noexcept
{
  return otp_;
}

void
Auth::setOtp(const std::string& pOtp) noexcept
{
  otp_ = std::make_shared<std::string>(pOtp);
  dirtyFlag_ [3] = true;
}

void
Auth::setOtp(std::string&& pOtp) noexcept
{
  otp_ = std::make_shared<std::string>(std::move(pOtp));
  dirtyFlag_ [3] = true;
}

void
Auth::setOtpToNull() noexcept
{
  otp_.reset();
  dirtyFlag_ [3] = true;
}

void
Auth::updateId(const uint64_t id)
{
}

const std::vector<std::string>&
Auth::insertColumns() noexcept
{
  static const std::vector<std::string> inCols =
    {"id", "verify_token", "refresh_token", "otp"};
  return inCols;
}

void
Auth::outputArgs(drogon::orm::internal::SqlBinder& binder) const
{
  if(dirtyFlag_ [0])
  {
    if(getId())
    {
      binder << getValueOfId();
    }
    else
    {
      binder << nullptr;
    }
  }
  if(dirtyFlag_ [1])
  {
    if(getVerifyToken())
    {
      binder << getValueOfVerifyToken();
    }
    else
    {
      binder << nullptr;
    }
  }
  if(dirtyFlag_ [2])
  {
    if(getRefreshToken())
    {
      binder << getValueOfRefreshToken();
    }
    else
    {
      binder << nullptr;
    }
  }
  if(dirtyFlag_ [3])
  {
    if(getOtp())
    {
      binder << getValueOfOtp();
    }
    else
    {
      binder << nullptr;
    }
  }
}

const std::vector<std::string>
Auth::updateColumns() const
{
  std::vector<std::string> ret;
  if(dirtyFlag_ [0])
  {
    ret.push_back(getColumnName(0));
  }
  if(dirtyFlag_ [1])
  {
    ret.push_back(getColumnName(1));
  }
  if(dirtyFlag_ [2])
  {
    ret.push_back(getColumnName(2));
  }
  if(dirtyFlag_ [3])
  {
    ret.push_back(getColumnName(3));
  }
  return ret;
}

void
Auth::updateArgs(drogon::orm::internal::SqlBinder& binder) const
{
  if(dirtyFlag_ [0])
  {
    if(getId())
    {
      binder << getValueOfId();
    }
    else
    {
      binder << nullptr;
    }
  }
  if(dirtyFlag_ [1])
  {
    if(getVerifyToken())
    {
      binder << getValueOfVerifyToken();
    }
    else
    {
      binder << nullptr;
    }
  }
  if(dirtyFlag_ [2])
  {
    if(getRefreshToken())
    {
      binder << getValueOfRefreshToken();
    }
    else
    {
      binder << nullptr;
    }
  }
  if(dirtyFlag_ [3])
  {
    if(getOtp())
    {
      binder << getValueOfOtp();
    }
    else
    {
      binder << nullptr;
    }
  }
}

Json::Value
Auth::toJson() const
{
  Json::Value ret;
  if(getId())
  {
    ret ["id"] = (Json::Int64)getValueOfId();
  }
  else
  {
    ret ["id"] = Json::Value();
  }
  if(getVerifyToken())
  {
    ret ["verify_token"] = getValueOfVerifyToken();
  }
  else
  {
    ret ["verify_token"] = Json::Value();
  }
  if(getRefreshToken())
  {
    ret ["refresh_token"] = getValueOfRefreshToken();
  }
  else
  {
    ret ["refresh_token"] = Json::Value();
  }
  if(getOtp())
  {
    ret ["otp"] = getValueOfOtp();
  }
  else
  {
    ret ["otp"] = Json::Value();
  }
  return ret;
}

Json::Value
Auth::toMasqueradedJson(const std::vector<std::string>& pMasqueradingVector
) const
{
  Json::Value ret;
  if(pMasqueradingVector.size() == 4)
  {
    if(! pMasqueradingVector [0].empty())
    {
      if(getId())
      {
        ret [pMasqueradingVector [0]] = (Json::Int64)getValueOfId();
      }
      else
      {
        ret [pMasqueradingVector [0]] = Json::Value();
      }
    }
    if(! pMasqueradingVector [1].empty())
    {
      if(getVerifyToken())
      {
        ret [pMasqueradingVector [1]] = getValueOfVerifyToken();
      }
      else
      {
        ret [pMasqueradingVector [1]] = Json::Value();
      }
    }
    if(! pMasqueradingVector [2].empty())
    {
      if(getRefreshToken())
      {
        ret [pMasqueradingVector [2]] = getValueOfRefreshToken();
      }
      else
      {
        ret [pMasqueradingVector [2]] = Json::Value();
      }
    }
    if(! pMasqueradingVector [3].empty())
    {
      if(getOtp())
      {
        ret [pMasqueradingVector [3]] = getValueOfOtp();
      }
      else
      {
        ret [pMasqueradingVector [3]] = Json::Value();
      }
    }
    return ret;
  }
  LOG_ERROR << "Masquerade failed";
  if(getId())
  {
    ret ["id"] = (Json::Int64)getValueOfId();
  }
  else
  {
    ret ["id"] = Json::Value();
  }
  if(getVerifyToken())
  {
    ret ["verify_token"] = getValueOfVerifyToken();
  }
  else
  {
    ret ["verify_token"] = Json::Value();
  }
  if(getRefreshToken())
  {
    ret ["refresh_token"] = getValueOfRefreshToken();
  }
  else
  {
    ret ["refresh_token"] = Json::Value();
  }
  if(getOtp())
  {
    ret ["otp"] = getValueOfOtp();
  }
  else
  {
    ret ["otp"] = Json::Value();
  }
  return ret;
}

bool
Auth::validateJsonForCreation(const Json::Value& pJson, std::string& err)
{
  if(pJson.isMember("id"))
  {
    if(! validJsonOfField(0, "id", pJson ["id"], err, true))
    {
      return false;
    }
  }
  else
  {
    err = "The id column cannot be null";
    return false;
  }
  if(pJson.isMember("verify_token"))
  {
    if(! validJsonOfField(1, "verify_token", pJson ["verify_token"], err, true))
    {
      return false;
    }
  }
  if(pJson.isMember("refresh_token"))
  {
    if(! validJsonOfField(
         2,
         "refresh_token",
         pJson ["refresh_token"],
         err,
         true
       ))
    {
      return false;
    }
  }
  if(pJson.isMember("otp"))
  {
    if(! validJsonOfField(3, "otp", pJson ["otp"], err, true))
    {
      return false;
    }
  }
  return true;
}

bool
Auth::validateMasqueradedJsonForCreation(
  const Json::Value& pJson,
  const std::vector<std::string>& pMasqueradingVector,
  std::string& err
)
{
  if(pMasqueradingVector.size() != 4)
  {
    err = "Bad masquerading vector";
    return false;
  }
  try
  {
    if(! pMasqueradingVector [0].empty())
    {
      if(pJson.isMember(pMasqueradingVector [0]))
      {
        if(! validJsonOfField(
             0,
             pMasqueradingVector [0],
             pJson [pMasqueradingVector [0]],
             err,
             true
           ))
        {
          return false;
        }
      }
      else
      {
        err = "The " + pMasqueradingVector [0] + " column cannot be null";
        return false;
      }
    }
    if(! pMasqueradingVector [1].empty())
    {
      if(pJson.isMember(pMasqueradingVector [1]))
      {
        if(! validJsonOfField(
             1,
             pMasqueradingVector [1],
             pJson [pMasqueradingVector [1]],
             err,
             true
           ))
        {
          return false;
        }
      }
    }
    if(! pMasqueradingVector [2].empty())
    {
      if(pJson.isMember(pMasqueradingVector [2]))
      {
        if(! validJsonOfField(
             2,
             pMasqueradingVector [2],
             pJson [pMasqueradingVector [2]],
             err,
             true
           ))
        {
          return false;
        }
      }
    }
    if(! pMasqueradingVector [3].empty())
    {
      if(pJson.isMember(pMasqueradingVector [3]))
      {
        if(! validJsonOfField(
             3,
             pMasqueradingVector [3],
             pJson [pMasqueradingVector [3]],
             err,
             true
           ))
        {
          return false;
        }
      }
    }
  }
  catch(const Json::LogicError& e)
  {
    err = e.what();
    return false;
  }
  return true;
}

bool
Auth::validateJsonForUpdate(const Json::Value& pJson, std::string& err)
{
  if(pJson.isMember("id"))
  {
    if(! validJsonOfField(0, "id", pJson ["id"], err, false))
    {
      return false;
    }
  }
  else
  {
    err = "The value of primary key must be set in the json object for update";
    return false;
  }
  if(pJson.isMember("verify_token"))
  {
    if(! validJsonOfField(
         1,
         "verify_token",
         pJson ["verify_token"],
         err,
         false
       ))
    {
      return false;
    }
  }
  if(pJson.isMember("refresh_token"))
  {
    if(! validJsonOfField(
         2,
         "refresh_token",
         pJson ["refresh_token"],
         err,
         false
       ))
    {
      return false;
    }
  }
  if(pJson.isMember("otp"))
  {
    if(! validJsonOfField(3, "otp", pJson ["otp"], err, false))
    {
      return false;
    }
  }
  return true;
}

bool
Auth::validateMasqueradedJsonForUpdate(
  const Json::Value& pJson,
  const std::vector<std::string>& pMasqueradingVector,
  std::string& err
)
{
  if(pMasqueradingVector.size() != 4)
  {
    err = "Bad masquerading vector";
    return false;
  }
  try
  {
    if(! pMasqueradingVector [0].empty() && pJson.isMember(pMasqueradingVector [0]))
    {
      if(! validJsonOfField(
           0,
           pMasqueradingVector [0],
           pJson [pMasqueradingVector [0]],
           err,
           false
         ))
      {
        return false;
      }
    }
    else
    {
      err =
        "The value of primary key must be set in the json object for update";
      return false;
    }
    if(! pMasqueradingVector [1].empty() && pJson.isMember(pMasqueradingVector [1]))
    {
      if(! validJsonOfField(
           1,
           pMasqueradingVector [1],
           pJson [pMasqueradingVector [1]],
           err,
           false
         ))
      {
        return false;
      }
    }
    if(! pMasqueradingVector [2].empty() && pJson.isMember(pMasqueradingVector [2]))
    {
      if(! validJsonOfField(
           2,
           pMasqueradingVector [2],
           pJson [pMasqueradingVector [2]],
           err,
           false
         ))
      {
        return false;
      }
    }
    if(! pMasqueradingVector [3].empty() && pJson.isMember(pMasqueradingVector [3]))
    {
      if(! validJsonOfField(
           3,
           pMasqueradingVector [3],
           pJson [pMasqueradingVector [3]],
           err,
           false
         ))
      {
        return false;
      }
    }
  }
  catch(const Json::LogicError& e)
  {
    err = e.what();
    return false;
  }
  return true;
}

bool
Auth::validJsonOfField(
  size_t index,
  const std::string& fieldName,
  const Json::Value& pJson,
  std::string& err,
  bool isForCreation
)
{
  switch(index)
  {
    case 0:
      if(pJson.isNull())
      {
        err = "The " + fieldName + " column cannot be null";
        return false;
      }
      if(! pJson.isInt64())
      {
        err = "Type error in the " + fieldName + " field";
        return false;
      }
      break;
    case 1:
      if(pJson.isNull())
      {
        return true;
      }
      if(! pJson.isString())
      {
        err = "Type error in the " + fieldName + " field";
        return false;
      }
      break;
    case 2:
      if(pJson.isNull())
      {
        return true;
      }
      if(! pJson.isString())
      {
        err = "Type error in the " + fieldName + " field";
        return false;
      }
      break;
    case 3:
      if(pJson.isNull())
      {
        return true;
      }
      if(! pJson.isString())
      {
        err = "Type error in the " + fieldName + " field";
        return false;
      }
      break;
    default:
      err = "Internal error in the server";
      return false;
  }
  return true;
}

// NOLINTEND